# TestkTask2
Тестовое задание на должность Unity разработчика

По вакансии получен отказ и фидбек. Объясняю косяки и принятые решения

- Баг: можно убить врагов на следующей точке и персонаж побежит дальше, игру дальше не пройти (верней можно, если враг к нам прибежит, но это явно не то поведение, которое требуется)
Соглашусь. Если убить пеередних врагов прежде, чем текущего, то игрок начнёт бежать к следующей точке, не проходя текущую

- Камера дергано переключается с одного врага на другого
Для прототипа решил не делать интерполяцию между ближайшими врагами (как в референсе), хотя скорость переключения можно было бы и сгладить

- Враги не разворачиваются, когда бегут к игроку
Тут да, недочёт из-за использования своего компонента для перемещения врагов, вместо NavMesh

- Неочевидные сокращения (одной буквой) - ухудшает читабельность кода
Если это про foreach, то я бы не согласился, т.к. код читается в контексте, а циклы занимают маленькое количество строк

- Использование UnityEvent - тоже
Смотря как выстраивать архитектуру. Благодаря событиям сборщику уровня можно изменять поведение уровня без кода. 

- Использование GetComponent без гарантии наличия компонента и без проверок на null
Про GetComponent в Awake - считаю такую практику правильной, т.к. сразу в дебаге можно увидеть ошибку и исправить её до того, как её увидят пользователи.
Но есть такая строка и в другом компоненте - TriggerTransformsContainer", где вызывается GetComponent<OnDisableEvent>(). Тут уже просчёт. 

- Синглотоны (player, камера)
Не считаю существование синглтонов плохой практикой. Совсем. Всё зависит от требований, а в таком прототипе этого было достаточно.

- Camera.main не закэширована
Я слышал, что в ранних версиях юнити были проблемы с производительностью из-за Camera.main, но в 2021 такого нет.

- Сравнение по тегу
Можно было бы создать пару компонентов и enum, но опять же, для прототипа этого было достаточно.

- Дублирующие списки врагов (для старта атаки и перехода к след точке)
Я считал, что продумал кое-какой сценарий, из-за которого иметь один список было бы нельзя (из-за геймдизайна), но сейчас понял, что такого сценария не может быть

- Остановка агента путем SetDestination на 0.1 метр вперед (используй isStopped = true)
Возможно, недочёт. Я помню, что в разработке другой игры у меня были проблемы с isStopped, поэтому я остерегался его в NavMesh.

- Вместо 9999999999999f используй Mathf.Infinity
Не использовал Infinity в других проектов, поэтому побоялся бага сравнения. Поленился написать небольшой тест для этого

- Вейпоинты не связаны с триггерами для начала боя. Подвинем точку, сломаем игру
Да, можно было сделать им одного родителя и создать из них префаб

- Вейпоинты сложно двигать, постоянно меняют свой поворот смотря в камеру. А должна двигаться только юайка точки.
У меня ни разу не было такой проблемы. Так как UI находится сверху точки, легко попасть по сфере, не попадая в границы Canvas
